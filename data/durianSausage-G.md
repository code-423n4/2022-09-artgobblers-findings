### G01: custom error save more gas
#### problem
Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information, as explained https://blog.soliditylang.org/2021/04/21/custom-errors/. 
Custom errors are defined using the error statement.
#### prof
src/ArtGobblers.sol, 437, b'                require(getGobblerData[id].owner == msg.sender, "WRONG_FROM");'
src/ArtGobblers.sol, 885, b'        require(from == getGobblerData[id].owner, "WRONG_FROM");'
src/ArtGobblers.sol, 887, b'        require(to != address(0), "INVALID_RECIPIENT");'
src/ArtGobblers.sol, 892, b'        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );'
lib/solmate/src/tokens/ERC721.sol, 36, b'        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");'
lib/solmate/src/tokens/ERC721.sol, 40, b'        require(owner != address(0), "ZERO_ADDRESS");'
lib/solmate/src/tokens/ERC721.sol, 69, b'        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");'
lib/solmate/src/tokens/ERC721.sol, 87, b'        require(from == _ownerOf[id], "WRONG_FROM");'
lib/solmate/src/tokens/ERC721.sol, 89, b'        require(to != address(0), "INVALID_RECIPIENT");'
lib/solmate/src/tokens/ERC721.sol, 94, b'        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );'
lib/solmate/src/tokens/ERC721.sol, 123, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
lib/solmate/src/tokens/ERC721.sol, 139, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
lib/solmate/src/tokens/ERC721.sol, 158, b'        require(to != address(0), "INVALID_RECIPIENT");'
lib/solmate/src/tokens/ERC721.sol, 160, b'        require(_ownerOf[id] == address(0), "ALREADY_MINTED");'
lib/solmate/src/tokens/ERC721.sol, 175, b'        require(owner != address(0), "NOT_MINTED");'
lib/solmate/src/tokens/ERC721.sol, 201, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
lib/solmate/src/tokens/ERC721.sol, 216, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
src/utils/token/GobblersERC721.sol, 62, b'        require((owner = getGobblerData[id].owner) != address(0), "NOT_MINTED");'
src/utils/token/GobblersERC721.sol, 66, b'        require(owner != address(0), "ZERO_ADDRESS");'
src/utils/token/GobblersERC721.sol, 95, b'        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");'
src/utils/token/GobblersERC721.sol, 126, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
src/utils/token/GobblersERC721.sol, 142, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
src/utils/token/PagesERC721.sol, 55, b'        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");'
src/utils/token/PagesERC721.sol, 59, b'        require(owner != address(0), "ZERO_ADDRESS");'
src/utils/token/PagesERC721.sol, 85, b'        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "NOT_AUTHORIZED");'
src/utils/token/PagesERC721.sol, 103, b'        require(from == _ownerOf[id], "WRONG_FROM");'
src/utils/token/PagesERC721.sol, 105, b'        require(to != address(0), "INVALID_RECIPIENT");'
src/utils/token/PagesERC721.sol, 110, b'        require(\n            msg.sender == from || isApprovedForAll(from, msg.sender) || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );'
src/utils/token/PagesERC721.sol, 139, b'            require(\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                    ERC721TokenReceiver.onERC721Received.selector,\n                "UNSAFE_RECIPIENT"\n            );'
src/utils/token/PagesERC721.sol, 155, b'            require(\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                    ERC721TokenReceiver.onERC721Received.selector,\n                "UNSAFE_RECIPIENT"\n            );'
src/utils/token/GobblersERC1155B.sol, 107, b'        require(owners.length == ids.length, "LENGTH_MISMATCH");'
src/utils/token/GobblersERC1155B.sol, 153, b'            require(\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, 1, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n                "UNSAFE_RECIPIENT"\n            );'
src/utils/token/GobblersERC1155B.sol, 189, b'            require(\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n                "UNSAFE_RECIPIENT"\n            );'
src/utils/token/GobblersERC721.sol, 62, b'        require((owner = getGobblerData[id].owner) != address(0), "NOT_MINTED");'
src/utils/token/GobblersERC721.sol, 66, b'        require(owner != address(0), "ZERO_ADDRESS");'
src/utils/token/GobblersERC721.sol, 95, b'        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");'
src/utils/token/GobblersERC721.sol, 126, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
src/utils/token/GobblersERC721.sol, 142, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
src/utils/token/PagesERC721.sol, 55, b'        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");'
src/utils/token/PagesERC721.sol, 59, b'        require(owner != address(0), "ZERO_ADDRESS");'
src/utils/token/PagesERC721.sol, 85, b'        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "NOT_AUTHORIZED");'
src/utils/token/PagesERC721.sol, 103, b'        require(from == _ownerOf[id], "WRONG_FROM");'
src/utils/token/PagesERC721.sol, 105, b'        require(to != address(0), "INVALID_RECIPIENT");'
src/utils/token/PagesERC721.sol, 110, b'        require(\n            msg.sender == from || isApprovedForAll(from, msg.sender) || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );'
src/utils/token/PagesERC721.sol, 139, b'            require(\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                    ERC721TokenReceiver.onERC721Received.selector,\n                "UNSAFE_RECIPIENT"\n            );'
src/utils/token/PagesERC721.sol, 155, b'            require(\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                    ERC721TokenReceiver.onERC721Received.selector,\n                "UNSAFE_RECIPIENT"\n            );'
lib/VRGDAs/src/VRGDA.sol, 32, b'        require(decayConstant < 0, "NON_NEGATIVE_DECAY_CONSTANT");'


### G02: PREFIX INCREMENT SAVE MORE GAS
#### problem
prefix increment ++i is more cheaper than postfix i++
#### prof
lib/solmate/src/tokens/ERC721.sol, 99, b'            _balanceOf[from]--;'
lib/solmate/src/tokens/ERC721.sol, 101, b'            _balanceOf[to]++;'
lib/solmate/src/tokens/ERC721.sol, 164, b'            _balanceOf[to]++;'
lib/solmate/src/tokens/ERC721.sol, 179, b'            _balanceOf[owner]--;'
src/utils/token/PagesERC721.sol, 115, b'            _balanceOf[from]--;'
src/utils/token/PagesERC721.sol, 117, b'            _balanceOf[to]++;'
src/utils/token/PagesERC721.sol, 181, b'            _balanceOf[to]++;'
src/utils/GobblerReserve.sol, 37, b'            for (uint256 i = 0; i < ids.length; i++) {'
src/Pages.sol, 251, b'            for (uint256 i = 0; i < numPages; i++) _mint(community, ++lastMintedPageId);'
src/utils/token/PagesERC721.sol, 115, b'            _balanceOf[from]--;'
src/utils/token/PagesERC721.sol, 117, b'            _balanceOf[to]++;'
src/utils/token/PagesERC721.sol, 181, b'            _balanceOf[to]++;'

### G03: X += Y COSTS MORE GAS THAN X = X + Y FOR STATE VARIABLES
#### prof
src/ArtGobblers.sol, 844, b'            uint256 newNumMintedForReserves = numMintedForReserves += (numGobblersEach << 1);'
src/Pages.sol, 244, b'            uint256 newNumMintedForCommunity = numMintedForCommunity += uint128(numPages);'


### G04: USING BOOLS FOR STORAGE INCURS OVERHEAD
#### problem
// Booleans are more expensive than uint256 or any type that takes up a full
// word because each write operation emits an extra SLOAD to first read the
// slot's contents, replace the bits taken up by the boolean, and then write
// back. This is the compiler's defense against contract upgrades and
// pointer aliasing, and it cannot be disabled.
#### prof
src/ArtGobblers.sol, 149, b'    mapping(address => bool) public hasClaimedMintlistGobbler;'
lib/solmate/src/tokens/ERC721.sol, 51, b'    mapping(address => mapping(address => bool)) public isApprovedForAll;'
src/utils/token/GobblersERC721.sol, 77, b'    mapping(address => mapping(address => bool)) public isApprovedForAll;'
src/utils/token/PagesERC721.sol, 70, b'    mapping(address => mapping(address => bool)) internal _isApprovedForAll;'
src/utils/token/GobblersERC1155B.sol, 37, b'    mapping(address => mapping(address => bool)) public isApprovedForAll;'
src/utils/token/GobblersERC721.sol, 77, b'    mapping(address => mapping(address => bool)) public isApprovedForAll;'
src/utils/token/PagesERC721.sol, 70, b'    mapping(address => mapping(address => bool)) internal _isApprovedForAll;'


### G05: resign the default value to the variables.
#### problem
 resign the default value to the variables will cost more gas.
#### prof
src/ArtGobblers.sol, 432, b'            for (uint256 i = 0; i < cost; ++i) {'
src/ArtGobblers.sol, 592, b'            for (uint256 i = 0; i < numGobblers; ++i) {'
src/utils/token/GobblersERC721.sol, 186, b'            for (uint256 i = 0; i < amount; ++i) {'
src/utils/GobblerReserve.sol, 37, b'            for (uint256 i = 0; i < ids.length; i++) {'
src/utils/token/GobblersERC1155B.sol, 114, b'            for (uint256 i = 0; i < owners.length; ++i) {'
src/utils/token/GobblersERC1155B.sol, 173, b'            for (uint256 i = 0; i < amount; ++i) {'
src/utils/token/GobblersERC721.sol, 186, b'            for (uint256 i = 0; i < amount; ++i) {'
src/Pages.sol, 251, b'            for (uint256 i = 0; i < numPages; i++) _mint(community, ++lastMintedPageId);'

### G06: ++I/I++ SHOULD BE UNCHECKED{++I}/UNCHECKED{I++} WHEN IT IS NOT POSSIBLE FOR THEM TO OVERFLOW, AS IS THE CASE WHEN USED IN FOR- AND WHILE-LOOPS
#### problem
The unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas per loop
#### prof
src/ArtGobblers.sol, 384, b'            ++numMintedFromGoo; // Overflow should be impossible due to the supply cap.'
src/ArtGobblers.sol, 432, b'            for (uint256 i = 0; i < cost; ++i) {'
src/ArtGobblers.sol, 605, b'                uint256 currentId = ++lastRevealedId;'
src/ArtGobblers.sol, 592, b'            for (uint256 i = 0; i < numGobblers; ++i) {'
src/ArtGobblers.sol, 741, b'            ++getCopiesOfArtGobbledByGobbler[gobblerId][nft][id];'
lib/solmate/src/tokens/ERC721.sol, 99, b'            _balanceOf[from]--;'
lib/solmate/src/tokens/ERC721.sol, 101, b'            _balanceOf[to]++;'
lib/solmate/src/tokens/ERC721.sol, 164, b'            _balanceOf[to]++;'
lib/solmate/src/tokens/ERC721.sol, 179, b'            _balanceOf[owner]--;'
src/utils/token/GobblersERC721.sol, 166, b'            ++getUserData[to].gobblersOwned;'
src/utils/token/GobblersERC721.sol, 186, b'            for (uint256 i = 0; i < amount; ++i) {'
src/utils/token/PagesERC721.sol, 115, b'            _balanceOf[from]--;'
src/utils/token/PagesERC721.sol, 117, b'            _balanceOf[to]++;'
src/utils/token/PagesERC721.sol, 181, b'            _balanceOf[to]++;'
src/utils/GobblerReserve.sol, 37, b'            for (uint256 i = 0; i < ids.length; i++) {'
src/utils/token/GobblersERC1155B.sol, 114, b'            for (uint256 i = 0; i < owners.length; ++i) {'
src/utils/token/GobblersERC1155B.sol, 173, b'            for (uint256 i = 0; i < amount; ++i) {'
src/utils/token/GobblersERC721.sol, 166, b'            ++getUserData[to].gobblersOwned;'
src/utils/token/GobblersERC721.sol, 186, b'            for (uint256 i = 0; i < amount; ++i) {'
src/Pages.sol, 251, b'            for (uint256 i = 0; i < numPages; i++) _mint(community, ++lastMintedPageId);'
src/Pages.sol, 251, b'            for (uint256 i = 0; i < numPages; i++) _mint(community, ++lastMintedPageId);'
src/utils/token/PagesERC721.sol, 115, b'            _balanceOf[from]--;'
src/utils/token/PagesERC721.sol, 117, b'            _balanceOf[to]++;'
src/utils/token/PagesERC721.sol, 181, b'            _balanceOf[to]++;'

### G07: Splitting require() statements that use && saves gas
#### problem
See this issue(https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper
#### prof:
src/ArtGobblers.sol, 892, b'        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );'
lib/solmate/src/tokens/ERC721.sol, 69, b'        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");'
lib/solmate/src/tokens/ERC721.sol, 94, b'        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );'
lib/solmate/src/tokens/ERC721.sol, 123, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
lib/solmate/src/tokens/ERC721.sol, 139, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
lib/solmate/src/tokens/ERC721.sol, 201, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
lib/solmate/src/tokens/ERC721.sol, 216, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
src/utils/token/GobblersERC721.sol, 95, b'        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");'
src/utils/token/GobblersERC721.sol, 126, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
src/utils/token/GobblersERC721.sol, 142, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
src/utils/token/PagesERC721.sol, 85, b'        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "NOT_AUTHORIZED");'
src/utils/token/PagesERC721.sol, 110, b'        require(\n            msg.sender == from || isApprovedForAll(from, msg.sender) || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );'
src/utils/token/GobblersERC721.sol, 95, b'        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");'
src/utils/token/GobblersERC721.sol, 126, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
src/utils/token/GobblersERC721.sol, 142, b'        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );'
src/utils/token/PagesERC721.sol, 85, b'        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "NOT_AUTHORIZED");'
src/utils/token/PagesERC721.sol, 110, b'        require(\n            msg.sender == from || isApprovedForAll(from, msg.sender) || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );'

### G08: FUNCTIONS GUARANTEED TO REVERT WHEN CALLED BY NORMAL USERS CAN BE MARKED PAYABLE
#### problem
If a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost
#### prof
src/ArtGobblers.sol, 471, b'    function mintLegendaryGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) '
src/ArtGobblers.sol, 567, b'    function upgradeRandProvider(RandProvider newRandProvider) external onlyOwner '
src/ArtGobblers.sol, 567, b'    function upgradeRandProvider(RandProvider newRandProvider) external onlyOwner '
src/ArtGobblers.sol, 685, b'    function revealGobblers(uint256 numGobblers) external '
src/ArtGobblers.sol, 749, b'    function gobble(\n        uint256 gobblerId,\n        address nft,\n        uint256 id,\n        bool isERC1155\n    ) external '
src/ArtGobblers.sol, 917, b'    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override '
lib/solmate/src/tokens/ERC721.sol, 37, b'    function ownerOf(uint256 id) public view virtual returns (address owner) '
lib/solmate/src/tokens/ERC721.sol, 37, b'    function ownerOf(uint256 id) public view virtual returns (address owner) '
lib/solmate/src/tokens/ERC721.sol, 43, b'    function balanceOf(address owner) public view virtual returns (uint256) '
lib/solmate/src/tokens/ERC721.sol, 43, b'    function balanceOf(address owner) public view virtual returns (uint256) '
lib/solmate/src/tokens/ERC721.sol, 74, b'    function approve(address spender, uint256 id) public virtual '
lib/solmate/src/tokens/ERC721.sol, 109, b'    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual '
lib/solmate/src/tokens/ERC721.sol, 170, b'    function _mint(address to, uint256 id) internal virtual '
lib/solmate/src/tokens/ERC721.sol, 187, b'    function _burn(uint256 id) internal virtual '
src/utils/token/GobblersERC721.sol, 63, b'    function ownerOf(uint256 id) external view returns (address owner) '
src/utils/token/GobblersERC721.sol, 63, b'    function ownerOf(uint256 id) external view returns (address owner) '
src/utils/token/GobblersERC721.sol, 69, b'    function balanceOf(address owner) external view returns (uint256) '
src/utils/token/GobblersERC721.sol, 69, b'    function balanceOf(address owner) external view returns (uint256) '
src/utils/token/GobblersERC721.sol, 100, b'    function approve(address spender, uint256 id) external '
src/utils/token/GobblersERC721.sol, 172, b'    function _mint(address to, uint256 id) internal '
src/utils/token/GobblersERC721.sol, 194, b'    function _batchMint(\n        address to,\n        uint256 amount,\n        uint256 lastMintedId\n    ) internal returns (uint256) '
src/utils/token/PagesERC721.sol, 56, b'    function ownerOf(uint256 id) external view returns (address owner) '
src/utils/token/PagesERC721.sol, 56, b'    function ownerOf(uint256 id) external view returns (address owner) '
src/utils/token/PagesERC721.sol, 62, b'    function balanceOf(address owner) external view returns (uint256) '
src/utils/token/PagesERC721.sol, 62, b'    function balanceOf(address owner) external view returns (uint256) '
src/utils/token/PagesERC721.sol, 76, b'    function isApprovedForAll(address owner, address operator) public view returns (bool isApproved) '
src/utils/token/PagesERC721.sol, 76, b'    function isApprovedForAll(address owner, address operator) public view returns (bool isApproved) '
src/utils/token/PagesERC721.sol, 90, b'    function approve(address spender, uint256 id) external '
src/utils/token/PagesERC721.sol, 125, b'    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public '
src/utils/token/PagesERC721.sol, 187, b'    function _mint(address to, uint256 id) internal '
src/utils/GobblerReserve.sol, 41, b'    function withdraw(address to, uint256[] calldata ids) external onlyOwner '
src/utils/GobblerReserve.sol, 41, b'    function withdraw(address to, uint256[] calldata ids) external onlyOwner '
src/utils/token/GobblersERC1155B.sol, 57, b'    function ownerOf(uint256 id) public view virtual returns (address owner) '
src/utils/token/GobblersERC1155B.sol, 57, b'    function ownerOf(uint256 id) public view virtual returns (address owner) '
src/utils/token/GobblersERC1155B.sol, 67, b'    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 bal) '
src/utils/token/GobblersERC1155B.sol, 67, b'    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 bal) '
src/utils/token/GobblersERC1155B.sol, 118, b'    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    '
src/utils/token/GobblersERC1155B.sol, 118, b'    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    '
src/utils/token/GobblersERC1155B.sol, 155, b'    function _mint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual '
src/utils/token/GobblersERC1155B.sol, 193, b'    function _batchMint(\n        address to,\n        uint256 amount,\n        uint256 lastMintedId,\n        bytes memory data\n    ) internal returns (uint256) '
src/utils/token/GobblersERC721.sol, 63, b'    function ownerOf(uint256 id) external view returns (address owner) '
src/utils/token/GobblersERC721.sol, 63, b'    function ownerOf(uint256 id) external view returns (address owner) '
src/utils/token/GobblersERC721.sol, 69, b'    function balanceOf(address owner) external view returns (uint256) '
src/utils/token/GobblersERC721.sol, 69, b'    function balanceOf(address owner) external view returns (uint256) '
src/utils/token/GobblersERC721.sol, 100, b'    function approve(address spender, uint256 id) external '
src/utils/token/GobblersERC721.sol, 172, b'    function _mint(address to, uint256 id) internal '
src/utils/token/GobblersERC721.sol, 194, b'    function _batchMint(\n        address to,\n        uint256 amount,\n        uint256 lastMintedId\n    ) internal returns (uint256) '
lib/solmate/src/auth/Owned.sol, 43, b'    function setOwner(address newOwner) public virtual onlyOwner '
lib/solmate/src/auth/Owned.sol, 43, b'    function setOwner(address newOwner) public virtual onlyOwner '
src/utils/token/PagesERC721.sol, 56, b'    function ownerOf(uint256 id) external view returns (address owner) '
src/utils/token/PagesERC721.sol, 56, b'    function ownerOf(uint256 id) external view returns (address owner) '
src/utils/token/PagesERC721.sol, 62, b'    function balanceOf(address owner) external view returns (uint256) '
src/utils/token/PagesERC721.sol, 62, b'    function balanceOf(address owner) external view returns (uint256) '
src/utils/token/PagesERC721.sol, 76, b'    function isApprovedForAll(address owner, address operator) public view returns (bool isApproved) '
src/utils/token/PagesERC721.sol, 76, b'    function isApprovedForAll(address owner, address operator) public view returns (bool isApproved) '
src/utils/token/PagesERC721.sol, 90, b'    function approve(address spender, uint256 id) external '
src/utils/token/PagesERC721.sol, 125, b'    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public '
src/utils/token/PagesERC721.sol, 187, b'    function _mint(address to, uint256 id) internal '


### G09: USING PRIVATE RATHER THAN PUBLIC FOR CONSTANTS, SAVES GAS
#### problem:
We can save getter function of public constants.
#### prof:
src/ArtGobblers.sol, 92, b'    Goo public immutable goo;'
src/ArtGobblers.sol, 95, b'    Pages public immutable pages;'
src/ArtGobblers.sol, 98, b'    address public immutable team;'
src/ArtGobblers.sol, 101, b'    address public immutable community;'
src/ArtGobblers.sol, 112, b'    uint256 public constant MAX_SUPPLY = 10000;'
src/ArtGobblers.sol, 115, b'    uint256 public constant MINTLIST_SUPPLY = 2000;'
src/ArtGobblers.sol, 118, b'    uint256 public constant LEGENDARY_SUPPLY = 10;'
src/ArtGobblers.sol, 122, b'    uint256 public constant RESERVED_SUPPLY = (MAX_SUPPLY - MINTLIST_SUPPLY - LEGENDARY_SUPPLY) / 5;'
src/ArtGobblers.sol, 129, b'    uint256 public constant MAX_MINTABLE = MAX_SUPPLY\n        - MINTLIST_SUPPLY\n        - LEGENDARY_SUPPLY\n        - RESERVED_SUPPLY;'
src/ArtGobblers.sol, 146, b'    bytes32 public immutable merkleRoot;'
src/ArtGobblers.sol, 156, b'    uint256 public immutable mintStart;'
src/ArtGobblers.sol, 177, b'    uint256 public constant LEGENDARY_GOBBLER_INITIAL_START_PRICE = 69;'
src/ArtGobblers.sol, 180, b'    uint256 public constant FIRST_LEGENDARY_GOBBLER_ID = MAX_SUPPLY - LEGENDARY_SUPPLY + 1;'
src/ArtGobblers.sol, 184, b'    uint256 public constant LEGENDARY_AUCTION_INTERVAL = MAX_MINTABLE / (LEGENDARY_SUPPLY + 1);'
src/utils/rand/ChainlinkV1RandProvider.sol, 20, b'    ArtGobblers public immutable artGobblers;'
script/deploy/DeployRinkeby.s.sol, 7, b'    address public immutable coldWallet = 0x126620598A797e6D9d2C280b5dB91b46F27A8330;'
script/deploy/DeployRinkeby.s.sol, 9, b'    address public immutable root = 0x1D18077167c1177253555e45B4b5448B11E30b4b;'
script/deploy/DeployRinkeby.s.sol, 11, b'    uint256 public immutable mintStart = 1656369768;'
script/deploy/DeployRinkeby.s.sol, 13, b'    string public constant gobblerBaseUri = "https://testnet.ag.xyz/api/nfts/gobblers/";'
script/deploy/DeployRinkeby.s.sol, 14, b'    string public constant gobblerUnrevealedUri = "https://testnet.ag.xyz/api/nfts/unrevealed";'
script/deploy/DeployRinkeby.s.sol, 15, b'    string public constant pagesBaseUri = "https://testnet.ag.xyz/api/nfts/pages/";'
src/utils/token/PagesERC721.sol, 34, b'    ArtGobblers public immutable artGobblers;'
src/utils/GobblerReserve.sol, 18, b'    ArtGobblers public immutable artGobblers;'
src/Goo.sol, 64, b'    address public immutable artGobblers;'
src/Goo.sol, 67, b'    address public immutable pages;'
lib/VRGDAs/src/LogisticVRGDA.sol, 20, b'    int256 public immutable logisticLimit;'
lib/VRGDAs/src/LogisticVRGDA.sol, 25, b'    int256 public immutable logisticLimitDoubled;'
src/Pages.sol, 86, b'    Goo public immutable goo;'
src/Pages.sol, 89, b'    address public immutable community;'
src/Pages.sol, 103, b'    uint256 public immutable mintStart;'
src/utils/token/PagesERC721.sol, 34, b'    ArtGobblers public immutable artGobblers;'
src/utils/rand/ChainlinkV1RandProvider.sol, 20, b'    ArtGobblers public immutable artGobblers;'
lib/VRGDAs/src/LogisticVRGDA.sol, 20, b'    int256 public immutable logisticLimit;'
lib/VRGDAs/src/LogisticVRGDA.sol, 25, b'    int256 public immutable logisticLimitDoubled;'
lib/VRGDAs/src/VRGDA.sol, 17, b'    int256 public immutable targetPrice;'

### G10: USAGE OF UINTS/INTS SMALLER THAN 32 BYTES (256 BITS) INCURS OVERHEAD
#### problem
When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.
#### prof
src/ArtGobblers.sol, 159, b'    uint128 public numMintedFromGoo;'
src/ArtGobblers.sol, 167, b'    uint128 public currentNonLegendaryId;'
src/ArtGobblers.sol, 324, b'        legendaryGobblerAuctionData.startPrice = uint128(LEGENDARY_GOBBLER_INITIAL_START_PRICE);'
src/ArtGobblers.sol, 327, b'        gobblerRevealsData.nextRevealTimestamp = uint64(_mintStart + 1 days);'
src/ArtGobblers.sol, 384, b'            ++numMintedFromGoo; // Overflow should be impossible due to the supply cap.'
src/ArtGobblers.sol, 401, b'        return getVRGDAPrice(toDaysWadUnsafe(timeSinceStart), numMintedFromGoo);'
src/ArtGobblers.sol, 432, b'            for (uint256 i = 0; i < cost; ++i) {'
src/ArtGobblers.sol, 449, b'            getGobblerData[gobblerId].emissionMultiple = uint32(burnedMultipleTotal * 2);'
src/ArtGobblers.sol, 454, b'            getUserData[msg.sender].lastBalance = uint128(gooBalance(msg.sender)); // Checkpoint balance.'
src/ArtGobblers.sol, 455, b'            getUserData[msg.sender].lastTimestamp = uint64(block.timestamp); // Store time alongside it.'
src/ArtGobblers.sol, 456, b'            getUserData[msg.sender].emissionMultiple += uint32(burnedMultipleTotal); // Update multiple.'
src/ArtGobblers.sol, 458, b'            getUserData[msg.sender].gobblersOwned = uint32(getUserData[msg.sender].gobblersOwned - cost + 1);'
src/ArtGobblers.sol, 463, b'            legendaryGobblerAuctionData.startPrice = uint120(\n                cost <= LEGENDARY_GOBBLER_INITIAL_START_PRICE / 2 ? LEGENDARY_GOBBLER_INITIAL_START_PRICE : cost * 2\n            );'
src/ArtGobblers.sol, 464, b'            legendaryGobblerAuctionData.numSold += 1; // Increment the # of legendaries sold.'
src/ArtGobblers.sol, 480, b'        uint256 startPrice = legendaryGobblerAuctionData.startPrice;'
src/ArtGobblers.sol, 481, b'        uint256 numSold = legendaryGobblerAuctionData.numSold;'
src/ArtGobblers.sol, 482, b'        uint256 mintedFromGoo = numMintedFromGoo;'
src/ArtGobblers.sol, 493, b'            uint256 numMintedSinceStart = numMintedFromGoo - numMintedAtStart;'
src/ArtGobblers.sol, 499, b'            else return FixedPointMathLib.unsafeDivUp(startPrice * (LEGENDARY_AUCTION_INTERVAL - numMintedSinceStart), LEGENDARY_AUCTION_INTERVAL);'
src/ArtGobblers.sol, 497, b'            if (numMintedSinceStart >= LEGENDARY_AUCTION_INTERVAL) return 0;'
src/ArtGobblers.sol, 510, b'        uint256 nextRevealTimestamp = gobblerRevealsData.nextRevealTimestamp;'
src/ArtGobblers.sol, 517, b'        if (gobblerRevealsData.toBeRevealed != 0) revert RevealsPending();'
src/ArtGobblers.sol, 517, b'        if (gobblerRevealsData.toBeRevealed != 0) revert RevealsPending();'
src/ArtGobblers.sol, 524, b'            uint256 toBeRevealed = currentNonLegendaryId - gobblerRevealsData.lastRevealedId;'
src/ArtGobblers.sol, 524, b'            uint256 toBeRevealed = currentNonLegendaryId - gobblerRevealsData.lastRevealedId;'
src/ArtGobblers.sol, 524, b'            uint256 toBeRevealed = currentNonLegendaryId - gobblerRevealsData.lastRevealedId;'
src/ArtGobblers.sol, 528, b'            if (toBeRevealed == 0) revert ZeroToBeRevealed();'
src/ArtGobblers.sol, 531, b'            gobblerRevealsData.toBeRevealed = uint56(toBeRevealed);'
src/ArtGobblers.sol, 535, b'            gobblerRevealsData.nextRevealTimestamp = uint64(nextRevealTimestamp + 1 days);'
src/ArtGobblers.sol, 551, b'        gobblerRevealsData.randomSeed = uint64(randomness); // 64 bits of randomness is plenty.'
src/ArtGobblers.sol, 577, b'        uint256 randomSeed = gobblerRevealsData.randomSeed;'
src/ArtGobblers.sol, 579, b'        uint256 lastRevealedId = gobblerRevealsData.lastRevealedId;'
src/ArtGobblers.sol, 581, b'        uint256 totalRemainingToBeRevealed = gobblerRevealsData.toBeRevealed;'
src/ArtGobblers.sol, 599, b'                uint256 remainingIds = FIRST_LEGENDARY_GOBBLER_ID - lastRevealedId - 1;'
src/ArtGobblers.sol, 615, b'                uint64 swapIndex = getGobblerData[swapId].idx == 0'
src/ArtGobblers.sol, 617, b"                uint64 swapIndex = getGobblerData[swapId].idx == 0\n                    ? uint64(swapId) // Hasn't been shuffled before.\n                    : getGobblerData[swapId].idx; // Shuffled before."
src/ArtGobblers.sol, 615, b'                uint64 swapIndex = getGobblerData[swapId].idx == 0'
src/ArtGobblers.sol, 615, b'                uint64 swapIndex = getGobblerData[swapId].idx == 0'
src/ArtGobblers.sol, 623, b'                uint64 currentIndex = getGobblerData[currentId].idx == 0'
src/ArtGobblers.sol, 625, b"                uint64 currentIndex = getGobblerData[currentId].idx == 0\n                    ? uint64(currentId) // Hasn't been shuffled before.\n                    : getGobblerData[currentId].idx; // Shuffled before."
src/ArtGobblers.sol, 623, b'                uint64 currentIndex = getGobblerData[currentId].idx == 0'
src/ArtGobblers.sol, 623, b'                uint64 currentIndex = getGobblerData[currentId].idx == 0'
src/ArtGobblers.sol, 632, b'                uint256 newCurrentIdMultiple = 9; // For beyond 7963.'
src/ArtGobblers.sol, 649, b'                getGobblerData[currentId].idx = swapIndex;'
src/ArtGobblers.sol, 650, b'                getGobblerData[currentId].emissionMultiple = uint32(newCurrentIdMultiple);'
src/ArtGobblers.sol, 653, b'                getGobblerData[swapId].idx = currentIndex;'
src/ArtGobblers.sol, 660, b'                getUserData[currentIdOwner].lastBalance = uint128(gooBalance(currentIdOwner));'
src/ArtGobblers.sol, 661, b'                getUserData[currentIdOwner].lastTimestamp = uint64(block.timestamp);'
src/ArtGobblers.sol, 662, b'                getUserData[currentIdOwner].emissionMultiple += uint32(newCurrentIdMultiple);'
src/ArtGobblers.sol, 592, b'            for (uint256 i = 0; i < numGobblers; ++i) {'
src/ArtGobblers.sol, 679, b'            gobblerRevealsData.randomSeed = uint64(randomSeed);'
src/ArtGobblers.sol, 680, b'            gobblerRevealsData.lastRevealedId = uint56(lastRevealedId);'
src/ArtGobblers.sol, 681, b'            gobblerRevealsData.toBeRevealed = uint56(totalRemainingToBeRevealed - numGobblers);'
src/ArtGobblers.sol, 695, b'        if (gobblerId <= gobblerRevealsData.lastRevealedId) {'
src/ArtGobblers.sol, 696, b'            if (gobblerId == 0) revert("NOT_MINTED"); // 0 is not a valid id for Art Gobblers.'
src/ArtGobblers.sol, 698, b'            return string.concat(BASE_URI, uint256(getGobblerData[gobblerId].idx).toString());'
src/ArtGobblers.sol, 698, b'            return string.concat(BASE_URI, uint256(getGobblerData[gobblerId].idx).toString());'
src/ArtGobblers.sol, 702, b'        if (gobblerId <= currentNonLegendaryId) return UNREVEALED_URI;'
src/ArtGobblers.sol, 708, b'        if (gobblerId < FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold)'
src/ArtGobblers.sol, 709, b'            return string.concat(BASE_URI, gobblerId.toString());'
src/ArtGobblers.sol, 761, b'            getUserData[user].emissionMultiple,'
src/ArtGobblers.sol, 762, b'            getUserData[user].lastBalance,'
src/ArtGobblers.sol, 763, b'            uint(toDaysWadUnsafe(block.timestamp - getUserData[user].lastTimestamp))'
src/ArtGobblers.sol, 825, b'        getUserData[user].lastBalance = uint128(updatedBalance);'
src/ArtGobblers.sol, 826, b'        getUserData[user].lastTimestamp = uint64(block.timestamp);'
src/ArtGobblers.sol, 848, b'            if (newNumMintedForReserves > (numMintedFromGoo + newNumMintedForReserves) / 5) revert ReserveImbalance();'
src/ArtGobblers.sol, 855, b'        currentNonLegendaryId = uint128(lastMintedGobblerId); // Set currentNonLegendaryId.'
src/ArtGobblers.sol, 867, b'        return getGobblerData[gobblerId].emissionMultiple;'
src/ArtGobblers.sol, 873, b'        return getUserData[user].emissionMultiple;'
src/ArtGobblers.sol, 887, b'        require(to != address(0), "INVALID_RECIPIENT");'
src/ArtGobblers.sol, 899, b'            uint32 emissionMultiple = getGobblerData[id].emissionMultiple; // Caching saves gas.'
src/ArtGobblers.sol, 899, b'            uint32 emissionMultiple = getGobblerData[id].emissionMultiple; // Caching saves gas.'
src/ArtGobblers.sol, 903, b'            getUserData[from].lastBalance = uint128(gooBalance(from));'
src/ArtGobblers.sol, 904, b'            getUserData[from].lastTimestamp = uint64(block.timestamp);'
src/ArtGobblers.sol, 905, b'            getUserData[from].emissionMultiple -= emissionMultiple;'
src/ArtGobblers.sol, 906, b'            getUserData[from].gobblersOwned -= 1;'
src/ArtGobblers.sol, 910, b'            getUserData[to].lastBalance = uint128(gooBalance(to));'
src/ArtGobblers.sol, 911, b'            getUserData[to].lastTimestamp = uint64(block.timestamp);'
src/ArtGobblers.sol, 912, b'            getUserData[to].emissionMultiple += emissionMultiple;'
src/ArtGobblers.sol, 913, b'            getUserData[to].gobblersOwned += 1;'
script/deploy/DeployBase.s.sol, 66, b'        address gobblerAddress = LibRLP.computeAddress(tx.origin, vm.getNonce(tx.origin) + 4);'
script/deploy/DeployBase.s.sol, 66, b'        address gobblerAddress = LibRLP.computeAddress(tx.origin, vm.getNonce(tx.origin) + 4);'
script/deploy/DeployBase.s.sol, 66, b'        address gobblerAddress = LibRLP.computeAddress(tx.origin, vm.getNonce(tx.origin) + 4);'
script/deploy/DeployBase.s.sol, 66, b'        address gobblerAddress = LibRLP.computeAddress(tx.origin, vm.getNonce(tx.origin) + 4);'
script/deploy/DeployBase.s.sol, 67, b'        address pageAddress = LibRLP.computeAddress(tx.origin, vm.getNonce(tx.origin) + 5);'
script/deploy/DeployBase.s.sol, 67, b'        address pageAddress = LibRLP.computeAddress(tx.origin, vm.getNonce(tx.origin) + 5);'
script/deploy/DeployBase.s.sol, 67, b'        address pageAddress = LibRLP.computeAddress(tx.origin, vm.getNonce(tx.origin) + 5);'
script/deploy/DeployBase.s.sol, 67, b'        address pageAddress = LibRLP.computeAddress(tx.origin, vm.getNonce(tx.origin) + 5);'
lib/solmate/src/tokens/ERC721.sol, 36, b'        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");'
lib/solmate/src/tokens/ERC721.sol, 40, b'        require(owner != address(0), "ZERO_ADDRESS");'
lib/solmate/src/tokens/ERC721.sol, 89, b'        require(to != address(0), "INVALID_RECIPIENT");'
lib/solmate/src/tokens/ERC721.sol, 119, b'            to.code.length == 0 ||'
lib/solmate/src/tokens/ERC721.sol, 135, b'            to.code.length == 0 ||'
lib/solmate/src/tokens/ERC721.sol, 148, b'            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165'
lib/solmate/src/tokens/ERC721.sol, 149, b'            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721'
lib/solmate/src/tokens/ERC721.sol, 150, b'            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata'
lib/solmate/src/tokens/ERC721.sol, 158, b'        require(to != address(0), "INVALID_RECIPIENT");'
lib/solmate/src/tokens/ERC721.sol, 160, b'        require(_ownerOf[id] == address(0), "ALREADY_MINTED");'
lib/solmate/src/tokens/ERC721.sol, 175, b'        require(owner != address(0), "NOT_MINTED");'
lib/solmate/src/tokens/ERC721.sol, 197, b'            to.code.length == 0 ||'
lib/solmate/src/tokens/ERC721.sol, 198, b'                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") =='
lib/solmate/src/tokens/ERC721.sol, 212, b'            to.code.length == 0 ||'
lib/solmate/src/tokens/ERC721.sol, 213, b'                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) =='
src/utils/token/GobblersERC721.sol, 62, b'        require((owner = getGobblerData[id].owner) != address(0), "NOT_MINTED");'
src/utils/token/GobblersERC721.sol, 66, b'        require(owner != address(0), "ZERO_ADDRESS");'
src/utils/token/GobblersERC721.sol, 68, b'        return getUserData[owner].gobblersOwned;'
src/utils/token/GobblersERC721.sol, 122, b'            to.code.length == 0 ||'
src/utils/token/GobblersERC721.sol, 138, b'            to.code.length == 0 ||'
src/utils/token/GobblersERC721.sol, 151, b'            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165'
src/utils/token/GobblersERC721.sol, 152, b'            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721'
src/utils/token/GobblersERC721.sol, 153, b'            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata'
src/utils/token/GobblersERC721.sol, 166, b'            ++getUserData[to].gobblersOwned;'
src/utils/token/GobblersERC721.sol, 184, b'            getUserData[to].gobblersOwned += uint32(amount);'
src/utils/token/GobblersERC721.sol, 186, b'            for (uint256 i = 0; i < amount; ++i) {'
src/utils/token/PagesERC721.sol, 55, b'        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");'
src/utils/token/PagesERC721.sol, 59, b'        require(owner != address(0), "ZERO_ADDRESS");'
src/utils/token/PagesERC721.sol, 105, b'        require(to != address(0), "INVALID_RECIPIENT");'
src/utils/token/PagesERC721.sol, 134, b'        if (to.code.length != 0)'
src/utils/token/PagesERC721.sol, 150, b'        if (to.code.length != 0)'
src/utils/token/PagesERC721.sol, 164, b'            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165'
src/utils/token/PagesERC721.sol, 165, b'            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721'
src/utils/token/PagesERC721.sol, 166, b'            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata'
src/utils/GobblerReserve.sol, 37, b'            for (uint256 i = 0; i < ids.length; i++) {'
src/utils/token/GobblersERC1155B.sol, 114, b'            for (uint256 i = 0; i < owners.length; ++i) {'
src/utils/token/GobblersERC1155B.sol, 126, b'            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165'
src/utils/token/GobblersERC1155B.sol, 127, b'            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155'
src/utils/token/GobblersERC1155B.sol, 128, b'            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI'
src/utils/token/GobblersERC1155B.sol, 148, b'        if (to.code.length != 0) {'
src/utils/token/GobblersERC1155B.sol, 150, b'                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, 1, data) =='
src/utils/token/GobblersERC1155B.sol, 150, b'                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, 1, data) =='
src/utils/token/GobblersERC1155B.sol, 173, b'            for (uint256 i = 0; i < amount; ++i) {'
src/utils/token/GobblersERC1155B.sol, 184, b'        if (to.code.length != 0) {'
src/utils/token/GobblersERC1155B.sol, 186, b'                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) =='
src/utils/token/GobblersERC721.sol, 62, b'        require((owner = getGobblerData[id].owner) != address(0), "NOT_MINTED");'
src/utils/token/GobblersERC721.sol, 66, b'        require(owner != address(0), "ZERO_ADDRESS");'
src/utils/token/GobblersERC721.sol, 68, b'        return getUserData[owner].gobblersOwned;'
src/utils/token/GobblersERC721.sol, 122, b'            to.code.length == 0 ||'
src/utils/token/GobblersERC721.sol, 138, b'            to.code.length == 0 ||'
src/utils/token/GobblersERC721.sol, 151, b'            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165'
src/utils/token/GobblersERC721.sol, 152, b'            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721'
src/utils/token/GobblersERC721.sol, 153, b'            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata'
src/utils/token/GobblersERC721.sol, 166, b'            ++getUserData[to].gobblersOwned;'
src/utils/token/GobblersERC721.sol, 184, b'            getUserData[to].gobblersOwned += uint32(amount);'
src/utils/token/GobblersERC721.sol, 186, b'            for (uint256 i = 0; i < amount; ++i) {'
src/Pages.sol, 107, b'    uint128 public currentId;'
src/Pages.sol, 114, b'    uint128 public numMintedForCommunity;'
src/Pages.sol, 227, b'            return getVRGDAPrice(toDaysWadUnsafe(timeSinceStart), currentId - numMintedForCommunity);'
src/Pages.sol, 227, b'            return getVRGDAPrice(toDaysWadUnsafe(timeSinceStart), currentId - numMintedForCommunity);'
src/Pages.sol, 227, b'            return getVRGDAPrice(toDaysWadUnsafe(timeSinceStart), currentId - numMintedForCommunity);'
src/Pages.sol, 244, b'            uint256 newNumMintedForCommunity = numMintedForCommunity += uint128(numPages);'
src/Pages.sol, 248, b'            if (newNumMintedForCommunity > ((lastMintedPageId = currentId) + numPages) / 10) revert ReserveImbalance();'
src/Pages.sol, 251, b'            for (uint256 i = 0; i < numPages; i++) _mint(community, ++lastMintedPageId);'
src/Pages.sol, 253, b'            currentId = uint128(lastMintedPageId); // Update currentId with the last minted page id.'
src/Pages.sol, 266, b'        if (pageId == 0 || pageId > currentId) revert("NOT_MINTED");'
src/Pages.sol, 266, b'        if (pageId == 0 || pageId > currentId) revert("NOT_MINTED");'
src/Pages.sol, 268, b'        return string.concat(BASE_URI, pageId.toString());'
src/utils/token/PagesERC721.sol, 55, b'        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");'
src/utils/token/PagesERC721.sol, 59, b'        require(owner != address(0), "ZERO_ADDRESS");'
src/utils/token/PagesERC721.sol, 105, b'        require(to != address(0), "INVALID_RECIPIENT");'
src/utils/token/PagesERC721.sol, 134, b'        if (to.code.length != 0)'
src/utils/token/PagesERC721.sol, 150, b'        if (to.code.length != 0)'
src/utils/token/PagesERC721.sol, 164, b'            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165'
src/utils/token/PagesERC721.sol, 165, b'            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721'
src/utils/token/PagesERC721.sol, 166, b'            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata'
lib/VRGDAs/src/VRGDA.sol, 32, b'        require(decayConstant < 0, "NON_NEGATIVE_DECAY_CONSTANT");'
lib/VRGDAs/src/VRGDA.sol, 50, b'                timeSinceStart - getTargetSaleTime(toWadUnsafe(sold + 1))'
risk all_discourage_safeApprove

### G11: USE A MORE RECENT VERSION OF SOLIDITY